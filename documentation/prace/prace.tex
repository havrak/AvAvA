\documentclass[a4paper,oneside,12pt]{report}
\setlength\textwidth{155mm}
\setlength\textheight{247mm}
\setlength\topmargin{-10mm}
\setlength\headheight{0mm}
\setlength\oddsidemargin{05mm}
\setlength\evensidemargin{05mm}
\let\openright=\clearpage


%% Vytváříme PDF/A-2u
\usepackage[a-2u]{pdfx}

%% Přepneme na českou sazbu a fonty Latin Modern
\usepackage[czech]{babel}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}

%% Použité kódování znaků: obvykle latin2, cp1250 nebo utf8:
\usepackage[utf8]{inputenc}

%%% Další užitečné balíčky (jsou součástí běžnýsrov.stribucí LaTeXu)
\usepackage{amsmath}        % rozšíření pro sazbu matematiky
\usepackage{amsfonts}       % matematické fonty
\usepackage{amsthm}         % sazba vět, definic apod.
\usepackage{bbding}         % balíček s nejrůznějšími symboly
			   										% (čtverečky, hvězdičky, tužtičky, nůžtičky, ...)
\usepackage{bm}             % tučné symboly (příkaz \bm)
\usepackage{graphicx}       % vkládání obrázků
\usepackage{fancyhdr}				% možnost slylizovat záhlaví
\usepackage{fancyvrb}       % vylepšené prostředí pro strojové písmo
\usepackage{indentfirst}    % zavede odsazení 1. odstavce kapitoly
\usepackage[nottoc]{tocbibind} % zajistí přidání seznamu literatury,
\usepackage{icomma}         % inteligetní čárka v matematickém módu
\usepackage{dcolumn}        % lepší zarovnání sloupců v tabulkách
\usepackage{booktabs}       % lepší vodorovné linky v tabulkách
\usepackage{paralist}       % lepší enumerate a itemize
\usepackage{caption}				%	popisky
\usepackage{dirtree}				% strom souborů
\usepackage{listings}				% vkládání kódu
\usepackage[bottom]{footmisc}  % poznámky pod čarou vespod
\usepackage{bibentry}
\usepackage{xurl}						% umožní url zalomit všude
\nobibliography*

\usepackage{color}
\usepackage{forest}					% na rodokmeny
\usepackage{natbib}
%\setbibentrystyle{author}

\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}
\definecolor{apiblue}{HTML}{000000}
\definecolor{apigreen}{HTML}{000000}
\definecolor{apicyan}{HTML}{000000} % vím, že cyan je jiná barva % vím, že cyan je jiná barva
\definecolor{apired}{HTML}{000000}
\definecolor{apiyellow}{HTML}{000000}
% \definecolor{apiblue}{HTML}{61AFFE}
% \definecolor{apigreen}{HTML}{49CC90}
% \definecolor{apicyan}{HTML}{50E3C2} % vím, že cyan je jiná barva % vím, že cyan je jiná barva
% \definecolor{apired}{HTML}{F93E3E}
% \definecolor{apiyellow}{HTML}{FCA130}
\renewcommand{\baselinestretch}{1.5}
%%% Údaje o práci

\def\NazevSkoly{Gymnázium, Praha 6, Arabská 14}
% Název oboru včetně počátečního 'Obor'.
\def\NazevOboru{Programování}

% Název práce v jazyce práce (přesně podle zadání)
\def\NazevPrace{Kontejnerizační systém pro školní server}

% Název práce v angličtině
\def\NazevPraceEN{Containerization system for school server}

% Název práce v němčině
\def\NazevPraceDE{Containerisierungssystem für Schulserver }

% Jméno autra
\def\AutorPrace{Havránek Kryštof, Vávra Vladimír, Litoš Josef 3.E }

% Rok odevzdání
\def\RokOdevzdani{2021}
% Měsíc odevzdání
\def\MesicOdevzdani{Duben}

% Vedoucí práce: Jméno a příjmení s~tituly
\def\Vedouci{Ing. Daniel Kahoun}

% Nepovinné poděkování (vedoucímu práce, konzultantovi, tomu, kdo
% zapůjčil software, literaturu apod.)
\def\Podekovani{%
\textbf{Poděkování}
}

% Abstrakt (doporučený rozsah cca 80-200 slov; nejedná se o zadání práce)
\def\Abstrakt{%
Cílem práce je vytvořit kontejnerizační systém pro operační systém GNU/Linux.
Ten by měl v jednoduchém a přehledném uživatelském prostředí umožnit žákům vytvořit si vlastní linuxový server.
Na kterém si poté mohou hostovat svoje aplikace, webové stránky.
Systém by se měl postarat o to, aby zdroje serveru byly spravedlivě rozdělené mezi jednotlivé uživatele.
}

\def\AbstraktEN{%
Goal of the work is to create containerization system for GNU/Linux operating system.
With its help students should be able to create their own private server in a easy to use webUI.
On such server they will be able to host their applications, websites.
System should also guarantee fair redistribution of server resources.
}
\def\AbstraktDE{%
Ziel des Werk ist ein Containerisierungssystem für das Betriebssystem GNU / Linux zu erstellen.
Es sollte den Schülern ihren eigenen Linux-Server in einer einfachen und übersichtlichen Benutzeroberfläche möglicher zu bilden.
Auf den Server können sie dann ihre Anwendungen, Websites oder Videospiele hosten, ich mag ein Brot.
Das System sollte sich zusichern, damit die Serverressourcen gerecht auf die individuellen Benutzer verteilt würden.
}
% 3 až 5 klíčových slov (doporučeno), každé uzavřeno ve složených závorkách
\def\KlicovaSlova{%
	{linux}, {lxd}, {lxc}, {kontejnery}, {nodejs}, {REST API}, {react js}
}
\def\KlicovaSlovaEN{%
	{linux}, {lxd}, {lxc}, {containers}, {nodejs}, {REST API}, {react js}
}

\def\KlicovaSlovaDE{%
	{linux}, {lxd}, {lxc}, {Schulprojekt}, {nodejs}, {REST API}, {react js}
}

%% Balíček hyperref, kterým jdou vyrábět klikací odkazy v PDF,
%% ale hlavně ho používáme k uložení metadat do PDF (včetně obsahu).
%% Většinu nastavítek přednastaví balíček pdfx.
\hypersetup{unicode}
\hypersetup{breaklinks=true}

%% Definice různých užitečných maker (viz popis uvnitř souboru)
\include{makra}

%% Titulní strana a různé povinné informační strany
\fancypagestyle{plain}{
\fancyhf{}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\fancyhead[C]{}
\fancyhead[L]{Ročníková práce -- \NazevSkoly}
\fancyhead[R]{AvAvA}
\fancyfoot[L]{Vypracovali: \AutorPrace	(\NazevOboru)}
\fancyfoot[C]{}
\fancyfoot[R]{\thepage}
}



\begin{document}

\include{titulka}

\tableofcontents


\newpage

\include{uvod}

\pagenumbering{arabic}
\setcounter{page}{1}

\chapter{Architektura}

\begin{figure}[h]
	\centering
	\includegraphics[height=9.5cm]{../img/architecture.png}
	\caption[Strukura projektu, vlastní tvorba]{Struktura projektu}
	\label{fig:architecture}
\end{figure}

Jádro práce stojí na LXD, což je kontejnerizační systém zabudovaný přímo do linuxového kernelu.
Jedná se tak o nejefektivnější řešení, protože jednotlivé kontejnery mohou sdílet společný kernel.
Jsou tedy menší a rychlejší, než kdyby se jednalo o VPS (Virtual Private Server).

Hierarchie jednotlivých komponent projektu sestává z uživatelů, projektů, které těmto uživatelům náleží, a kontejnery, což jsou samotné virtuální servery, které si uživatel může pod hlavičkou projektu vytvořit, určené k testování, hostování webových stránek, či jiné.
To umožňuje mít v serverech jistou organizaci, kde projekty představují třeba záložku a kontejnery pak její obsah.
Zároveň také může uživatel omezit limity jednoho projektu, a získané prostředky přiřadit jinému projektu, kde třeba má testovací kontejnery, pro které potřebuje větší výkon atd.

Backend s lxd komunikuje prostřednictvím REST API, které lxd přímo podporuje.
Samotný backend je napsán v NodeJS a ke svému fungování využívá dva databázové systémy.
Většinu informací ukládá do MySQL databáze, ale kvůli komplikacím s LXD byla později zavedena i MongoDB.

Frontend je psán v ReactJS a s backendem komunikuje prostřednictvím vlastního REST API (jehož podrobná specifikace je uvedena v dokumentaci).
Na frontendu může uživatel v pohodlném prostředí vytvářet nové kontejnery, projekty, získat informace o jejich aktuálním stavu a mnohé další.


\section{Specifikace vlastního API}

Následující sekce prochází jednotlivé routy.
API bylo vytvořeno za pomocí nástroje \url{editor.swagger.io}.
Jeho technická specifikace se nachází v souboru USER.yaml.


\subsubsection{\color{apiblue}{GET -- /api/combinedData}}

Routa GET /api/combinedData vrací objekt UserData.
Odpověď obsahuje data o uživateli, informace potřebné k vytvoření nového kontejneru (Dostupné šablony a aplikace, které je možno nainstalovat.)
Mimo to je v odpovědi objekt UserProjects, který v sobě má uložené limity uživatele a informace o všech jeho projektech.
Jedná se o jeden z prvních požadavků co frontend zavolá.

\subsubsection{\color{apiblue}{POST -- /api/instances}}

Routa POST /api/instances umožňuje uživateli vytvořit nový kontejner.
Překročil li uživatel aktuální maximální limity, či vytvoření kontejneru selhalo vrátí se uživateli chybová hláška s kódem 400.
Kontejner se pochopitelně smaže z databáze, kam je nutné ho prvně uložit.

Požadavek také umožňuje nechat na kontejner nainstalovat aplikace, selže li jejich instalace uživatel se o tom nedozví.
Kontejner se však nesmaže.

Vytvoří li se dobře kontejner vrátí se uživateli Container objekt obsahující informace o právě vytvořeném kontejneru.
Na backendu se zároveň vygeneruje nový konfigurační soubory proxy (viz. Backend$\Rightarrow$ Networking $\Rightarrow$ Proxy).


\subsubsection{\color{apiblue}{GET -- /api/instances/createInstanceConfigData}}

Routa GET /api/instances/createInstanceConfigData slouží vrací objekt createInstanceConfigData.
Je volána vždy před vytvořením nového kontejneru, aby uživatel měl na výběr mezi nejnovější nabídkou šablon a aplikací, které je možno nainstalovat.

\subsubsection{\color{apiblue}{GET -- /api/instances/\{id\}}}

Routa GET /api/instances/\{id\} vrací objekt Container.
V něm jsou uložené informace o dotazovaném kontejneru, jako jsou jeho limity, či aktuální stav.
Jak bylo zmíněno v autorizaci, uživatel se může zeptat pouze na kontejnery, které vlastní, či je na nich uveden jako spolupracovník.

\subsubsection{\color{apicyan}{PATCH -- /api/instances/\{id\}}}

Routa PATCH /api/instances/\{id\} slouží k změně limitů kontejnerů.
Aktuálně není změna limitů na backendu implementována.
Po změně limitů by se měla vrátit objekt Container s novými limity a všechny záznamy v containersResourcesLog by byly vymazány.
Změna limitů jde provádět pouze na vypnutém kontejneru, o to by se routa postarala.

\subsubsection{\color{apired}{DELETE -- /api/instances/\{id\}}}

Routa DELETE /api/instances/\{id\} slouží k smazání vybraného kontejneru.
Operace nejde nijak revertnou, neudělal li si uživatel backup.
Kontejner se jednoduše smaže z databáze a z lxd systému.

\subsubsection{\color{apiblue}{GET -- /api/instances/\{id\}/stateWithHistory}}

Routa GET /api/instances/\{id\}/stateWithHistory vrací pole objektů ContainerStateWithHistory.
V něm je uloženo id kontejneru a logy stavu kontejneru (prostřednictvím ContainerResourceState).
S aktuální konfigurací je stav zaznamenává co deset minut dvě hodiny nejstarší stav byl zaznamenám před 2 hodinami.

V objektech jsou vyplněna pouze pole, které jsou uloženy v databázi, tedy informace o stavu ram, cpu, počtu procesů, rychlosti uploadu, rychlosti downloadu a limity.
Výjimku představuje poslední ContainerResourceState v poli, kde je uložen aktuální stav, který se získá přes volání do lxd.

\subsubsection{\color{apiblue}{GET -- /api/instances/\{id\}/console}}

Routa GET /api/instances/\{id\}/console slouží realizaci konzole ve webovém prostředí.
Na serveru se vytvoří websocket s konzolí a přihlašovací údaje na něj se zašlou uživateli.

\subsubsection{\color{apiblue}{GET -- /api/instances/\{id\}/snapshots}}

Routa GET /api/instances/\{id\}/snapshots má sloužit k získání snapshotů kontejnerů.
V aktuální verzi není routa implementována, obnovení snapshotu se totiž objevilo jako velmi problematické.
Podobně jako u backupu se i u snapshotu musí řešit limity, zde jsou však uložené ve snapshotu.
Uživatel by měl možnost vybrat si jaký snapshots chce obnovit a jaké jeho limity se mají dodržet.
Logika obnovení byla příliš složitá a její realizace se nestihla včas udělat.
Došli jsem také k závěru, že snapshoty by jsou potenciální bezpečností riziko, jelikož nejde limitovat místo, které zabírají.


\subsubsection{\color{apigreen}{POST -- /api/instances/\{id\}/snapshots}}

Routa POST /api/instances/\{id\}/snapshots by měla vyvolat vytvoření snapshotu kontejneru.
Stejně jako další routy týkající se logiky snapshotů ani tato nebyla implementována.

\subsubsection{\color{apired}{DELETE -- /api/instances/\{id\}/snapshots/\{snapshotsid\}}}

Routa DELETE /api/instances/\{id\}/restore/\{snapshotsid\} by měla smazat snapshots
Stejně jako další routy týkající se logiky snapshotů ani tato nebyla implementována.

\subsubsection{\color{apicyan}{PATCH -- /api/instances/\{id\}/restore/\{snapshotsid\}}}

Routa PATCH /api/instances/\{id\}/restore/\{snapshotsid\} by měla obnovit stav kontejneru dle snapshotu.
Stejně jako další routy týkající se logiky snapshotů ani tato nebyla implementována.

\subsubsection{\color{apiblue}{GET -- /api/instances/\{id\}/export}}

Routa GET /api/instances/\{id\}/export slouží k exportování backupu.
Po jejím zavolání se na serveru vytvoří backup kontejneru a přes data stream se pošle uživateli.
Aktuálně je kompresován ve formátu .tar.gz.

\subsubsection{\color{apiyellow}{PUT -- /api/instances/import}}

Routa PUT /api/instances/import má sloužit k importu backupu kontejneru.
V aktuální verzi není routa implementována, je totiž problematické zjistit stav limitů z backup.
Routa by měla kontejner deplounout v sandboxu a zjistit si jeho limity.
Poté ověřit zda uživatel má volné zdroje na jeho vytvoření, pokud ano kontejner by se vytvořil a zapsal do databáze.


\subsubsection{\color{apicyan}{PATCH -- /api/instances/\{id\}/start}}

Routa PATCH  /api/instances/\{id\}/start slouží k nastartování kontejneru.
Pokud se kontejner nastartuje jeho aktuální stav se uloží do databáze a vygeneruje se objekt Container.
Ten se pošle jako odpověď na požadavek.

\subsubsection{\color{apicyan}{PATCH -- /api/instances/\{id\}/stop}}

Routa PATCH  /api/instances/\{id\}/stop slouží k stopnutí kontejneru.
Před zastavením se uloží jeho stav, se změněnými hodnotami (status bude stopped, využití ram nula, atd.), do mongoDB.
Není totiž možné získat stav kontejneru je li stopnutý.
Pokud se kontejner pozastaví jeho aktuální stav se uloží do mySQL databáze a vygeneruje se objekt Container.
Ten se pošle jako odpověď na požadavek.


\subsubsection{\color{apicyan}{PATCH -- /api/instances/\{id\}/freeze}}

Routa PATCH  /api/instances/\{id\}/freeze slouží k zmražení kontejneru.
Pokud se kontejner zmrazí jeho aktuální stav se uloží do databáze a vygeneruje se objekt Container.
Ten se pošle jako odpověď na požadavek.


\subsubsection{\color{apicyan}{PATCH -- /api/instances/\{id\}/unfreeze}}

Routa PATCH  /api/instances/\{id\}/unfreeze slouží k rozmražení kontejneru.
Pokud se kontejner rozmrazí jeho aktuální stav se uloží do databáze a vygeneruje se objekt Container.
Ten se pošle jako odpověď na požadavek.


\subsubsection{\color{apiblue}{GET -- /api/projects}}

Routa GET /api/projects vrací objekt UserProjects.
V něm jsou uložené limity uživatele a pole objektů Project s inforamcemi o jeho projektech a kontejnerech v nich.

\subsubsection{\color{apigreen}{POST -- /api/projects}}

Routa POST /api/projects slouží k vytvoření nové projektu.
Prvně se zkontroluje, zda uživatel má místo na jeho vytvoření.
Pokud ano, tak se vygeneruje JSON, jenž se odešle do lxd.

Systém podporuje projekt s nulovými (null, ne nula) limity, aktuálně je však nejde mixovat.

Odpovědí na request je objekt Projekt, který se vygeneruje je li vytvoření projektu úspěšné.

\subsubsection{\color{apiblue}{GET -- /api/projects/stateWithHistory}}

Routa GET /api/projects/stateWithHistory vrací objekt UserStateWithHistory.
V něm je uložená historie všech projektů uživatele, které obsahuje historii jeho všech kontejnerů.

\subsubsection{\color{apiblue}{GET -- /api/projects/\{id\}}}

Routa GET /api/projects/\{id\} vrací objekt Project s informacemi o projektu.
Ten si mimo jiné pamatuje limity, název, spolupracovníky a pole Container objektů.

\subsubsection{\color{apicyan}{PATCH -- /api/projects/\{id\}}}

Routa PATCH /api/projects/\{id\} slouží k úpravě limitů projektu.
V aktuální verzi je možno limity pouze zvýšit a projekt přejmenovat.
Je li projekt přejmenován vygeneruje se nová konfigurace proxy.
Odpovědí na request je objekt Project s novými limity projektu.

\subsubsection{\color{apired}{DELETE -- /api/projects/\{id\}}}

Routa DELETE /api/projects/\{id\} slouží k smazání projektu.
Stejně jako  smazání kontejneru ani smazání projektu nejde vrátit zpět.
Metoda prvně smaže veškeré kontejnery nacházející se v projektu a poté projekt samotný.

\subsubsection{\color{apiblue}{GET -- /api/projects/\{id\}/stateWithHistory}}

Routa GET /api/projects/\{id\}/stateWithHistory vrací objekt ProjectStateWith History.
V něm je uložená historie všech kontejnerů projektu, která využívá stejnou metodu jako GET /api/instances/stateWithHistory.

\subsubsection{\color{apiblue}{GET -- /api/user}}

Routa GET /api/user vrací objekt User.
Jedná se o právě přihlášeného uživatele.

\subsubsection{\color{apiblue}{GET -- /api/logout}}

Routa GET /api/logout uživatel odhlásí ze systému.

\section{LXD}

Následující kapitola spěšně projede princip integrace LXD do našeho projektu.
Programová stránka je později rozvedena v backednu.

Veškeré dorozumívání se projektu s LXD probíhá přes REST API\footnote{\bibentry{lxd}}.
Pro zjednodušení všech odchozích požadavků obsahuje backend soubor lxdRoute.js, který projektu poskytuje snadný a efektivní přístup k datům LXD.
Tato kapitola uvádí výslednou strukturu komunikace mezi rozhraními, využité funkce poskytované LXD a s nimi spojené potřebné postupy – MongoDB a WebSocket komunikace.

\subsubsection{Princip obecné komunikace s LXD}

Všechny vnější požadavky na LXD prochází přes soubor lxdRoute.js, který je určen výhradně právě k tomuto účelu.
Poskytuje metody pro každou jednoduchou akci potřebnou pro, jak zjištění/doplnění dat jistých objektů – projekty, kontejnery, jejich stav, zálohy nebo i snapshoty --, tak provedení určitých akcí -- změnit stav/limity kontejneru, spustit příkaz/konzoli, nahrát/stáhnout soubory/zálohy… Výsledky jsou zpracovány do využívaných údajů, které se vrátí volajícímu.
Tím úloha prostředníka mezi backendem a LXD démonem končí.

\subsection{Využité funkce LXD}

Celkové množství funkcí, které LXD poskytuje, zdaleka převyšuje potřebu tohoto projektu, je proto nutné uvést, kterých prvků a rout bylo nakonec využito.
Některé funkce byly v plánu, avšak, jak jsme posléze zjistili, jsou špatně implementovány a jejich použití v lepším případě nemá význam, v horším pak vyvolává náhodné chování kontejnerů (viz Práce s limity).

Základními nezbytnými funkcemi jsou akce s kontejnery a vytváření a mazání projektů; funkce, jako vytváření profilů, .img souborů, clustery nebo práce se šablonami (templates), nebyly využity, neboť se veškerá omezení nastavují pomocí limitů a zdroje pocházejí z jednoho serveru, používá se proto všude jeden disk a jedno internetové připojení.
Výběr z obrazů operačních systémů je také jen jeden – není důvod omezovat projektům výběr systému používaného pro kontejnery.

Oproti funkcím projektu, kde využíváme jen routy na vytvoření a smazání, jsou u kontejnerů užívané téměř všechny routy.
Většinou se ale jedná o jednoduché poslání dotazu na stav nebo měnění stavu kontejneru.

\subsubsection{Zakomponování LXD do MongoDB}

Zjišťování stavu se jen lehce komplikuje při vypnutém kontejneru, jelikož LXD v tomto stavu nevrací data o internetu a využitém disku.
Pročež je potřeba chybějící data uložit, ještě když jsou k dispozici.
Za tímto účelem byl využit databázový framework MongoDB.

\subsubsection{Práce s limity}

Náročnějšími funkcemi jsou pak používání virtuálního terminálu kontejneru (viz Komunikace přes WebSocket), a také nastavování limitů, což tvoří jednu z nejkomplikovanějších částí projektu, která vyžaduje vícero dalších, dotazu předcházejících operaci.

Zdroje, které jsou k dispozici kontejnerům, se vytváří podle limitů projektu, přesněji jejich zbývající části, která je dostupná. Limity projektů se sestavují ve stejném vztahu k uživateli, jehož limity jsou předdefinované v základu stejně pro všechny uživatele.
I uživatel si ale může navýšit své limity, a to zažádáním o navýšení limitů.

\subsubsection{Využití komunikace přes protokol WS (websocket)}
Pro jisté funkce bylo třeba zavést také používání protokolu WS.
Dokumentace LXD uvádí, že je možné provádět veškeré operace tímto stylem, avšak pro jednoduchost a přehlednost byla tato možnost ponechána pouze pro nezbytné prvky projektu, kterými jsou funkce terminálu v kontejnerech a aktualizování rozměrů okna terminálu v LXD, aby byl výsledný text u klienta správně zobrazován.
Tyto dvě funkce sdílejí stejnou cestu, na kterou se lze připojit, rozlišují se pomocí id websocketu -- /websockets/terminals/[id websocketu].


\section{Autentifikace}

\begin{figure}[h]
	\centering
	\includegraphics[height=9.5cm]{../img/authentication.png}
	\caption[Autentifikace přes Google Auth, vlastní tvorba]{Autentifikace přes Google Auth}
	\label{fig:architecture}
\end{figure}

Za způsob autentifikace uživatelů byl zvolen Google Auth, jelikož všichni studenti gymnázia Arabská mají svůj vlastní školní Google účet. Díky tomu si každý student bude moci vytvořit vlastní server bez nutnosti registrace.

Pro zprovoznění autentifikace je nejprve nutné si v Google Console vytvořit nový projekt.
Aktuálně je tento projekt hoštěn na studentském Google účtu \url{vladimir.vavra@student.gyarab.cz.} % easyest way to force linebreak
Je nastavené, že pouze uživatelé v rámci domény .gyarab se mohou do systému přihlásit.
Poté, co se nastaví všechna potřebná data je vygenerován clientId a clientSecret, což jsou kódy, pomocí nichž se bude AvAvA autorizovat

\subsection{Princip fungování}

Na obrázku výše můžete vidět průběh autentifikačního procesu.
Nejprve uživatel musí autentifikaci zahájit, což udělá pokusem o získání nějakého chráněného obsahu.
Po odeslání žádosti z klienta na backend přesměruje uživatele na přihlašovací stránku Google.
V případě, že se student přihlásí poprvé, musí odsouhlasit, že povoluje programu využívat některé služby.
Při dalších návštěvách se už jen přihlásí.

Tím je proces autentifikace hotov a začíná proces autorizace programu u Googlu.
AvAvA tedy bude Google žádat, aby jí předal data o uživateli, která potřebuje.
To dělá v obdélníku “odelsat request s kódem do google”.
Pokud google vyhoví, zavolá callback, který mu byl nastaven při vytváření projektu v Google Console a odešle na něj chtěná data.
Při první přihlášení se o něm uložen záznam do databáze, se kterým poté backend bude párovat kontejnery a projekty.
Následně je vytvořena session mezi frontendem a backendem. Každá zpráva odteď bude v hlavičce obsahovat cookie soubor s ID uživatele.

Po získání dat je uživatel přihlášen a může systém používat. Při odhlášení je session ukončena a už se dále user ID neposílá.

\subsection{Implementace}


Při implementaci byla hlavním zdrojem informací videa, ze kterých jsme získali část kódu\footnote{\bibentry{googleAuth}}.
Jelikož celý proces autentifikace probíhal na backendu, je uživatel odkázán na frontendovou cestu /userSetup. To je signál, že se uživatel přihlásil a frontend tedy pošle žádost na /api/combinedData.

Pro implementaci tohoto procesu na backendu bylo využito knihovny passport.js, která celý proces usnadňuje. Jediné, co je potřeba udělat je implementovat metody serializeUser a deserializeUser, které se budou volat po pořadě při zapisování ID do sessioncookie a při získávání uživatele z databáze za pomoci ID získané ze sessioncookie.

Je také nutné zapsat kód, který se zavolá hned po přihlášení, tedy uložení do databáze - passport.use(...) a předat passportu clientId a secretId.

Pro zjištění, zda je uživatel přihlášen je možné na kterékoliv z request objektů získat property req.user, ve které bude uložen výsledek posledního volání metody deserializeUser. V případě, že žádný uživatel není přihlášen, jeho hodnota je null. K tomuto účelu slouží metoda isLoggedIn.


\subsection{Autorizace}

Pro každý request do API se zkontroluje, zda je uživatel přihlášen.
Není li přihlášen vrátí se mu kód 401 se zprávou, že není autentifikován.
Jelikož metody počítají s emailem, který do requestů přidává Google Auth, tak není možné vykonat pro nepřihlášeného uživatele ani get requesty.
Navíc není, žádoucí aby uživatel viděl stav ostatních uživatelů.

Routy, které obsahují id kontejneru, či projektu si ověřují zda odesílatel requestu má právo upravovat kontejneru.
U kontejneru, k tomu slouží metoda userSQL.doesUser\linebreak OwnGivenContainer(email,id).
Ta interně zavolá metod userSQL.doesUserOwnGiven\linebreak Project(email, id), poté co zjistí id projektu z databáze.
Činý tak jelikož pokud má uživatel právo na projektu, má zároveň právo na jeho kontejneru.

V aktuálním podobě se ověřuje, zda je uživatel uveden buďto jako vlastník, nebo spolupracovník na projektu.
Eventuálně by měl superadmin a admin mít právo cizí kontejnery do určité míry ovlivňovat.
Konkrétně admin na ně pouze nahlížet a superadmin s nimi volně zacházet a měnit je.

Ověření metodou userSQL.doesUserOwnGivenProject(email, id) používá také routa /api/instances\#POST.
Zde je třeba ověřit zda uživatel vlastní projekt, do kterého se snaží vytvořit nový kontejner.


\chapter{Frontend}

Základem pro frontend se stal dashboard template\footnote{viz. \bibentry{templates}}.
 Požadavky aplikace ovšem tento template ani zdaleka nedokázal splnit. Jedinými částmi, které tedy přebrány je layout aplikace (soubor User), design Sidebaru a Navbaru, včetně jejich mobilních verzí.
 I tyto části ovšem musely být modifikovány, aby vyhovovaly všem nárokům aplikace.
 Zároveň také z templatu zůstaly scss soubory.
 Ty jsou ovšem využívány některými komponentami, takže zatím soubory nebyly z projektu vymazány.

 Kód byl napsaný v Javascriptu, konkrétně ReactJS a preprocessoru SASS. Velice důležité jsou i knihovny react-bootstrap a material-ui, pomocí nichž byla napsána většina komponent.

\section{Struktura souborů}

Následující sekce popisuje strukturu souborů clienta.

\begin{figure}[h]
	\dirtree{%
	.1 client.
	.2 node\_modules.
	.2 public.
	.2 src.
	.3 actions.
	.3 api.
	.3 assets.
	.3 components.
	.3 layouts.
	.3 reducers.
	.3 service.
	.3 views.
	.3 App.js.
	.3 index.js.
	.3 logo.svg.
	.3 routes.js.
	.3 setupProxy.js.
	}
	\caption[Struktura souborů frontendu, vlastní tvorba]{Struktura souborů frontend}
	\label{fig:frontendStructure}
\end{figure}


%public
\newpage
\subsubsection{Public}

\begin{figure}[h]
	\dirtree{%
	.1 client.
	.2 public.
	.3 favicon.ico.
	.3 index.html.
	}
	\caption[Struktura souborů frontendu -- public, vlastní tvorba]{Struktura souborů frontend -- public}
	\label{fig:frontendStructure}
\end{figure}
Ve složce public se nachází pouze jeden HTML soubor s root divem, do kterého React zapisuje.
Favicon je poté LXD ikona, která se objeví jako ikona karty prohlížeče.

Soubory .eslintcache, package=lock.json jsou automaticky generované a nejsou tedy důležité.
Soubor gulpfile.js připne k HTML a CSS souborům hlavičku, kterou vyžaduje licence templatu.
Soubor jsconfig.json poté dovolí importovat soubory pomocí absolutních cest vzhledem k src složce, což činí práci s importy mnohem pohodlnější

\subsubsection{Src}
\begin{figure}[h]
	\dirtree{%
	.1 client.
	.2 src.
	.3 actions.
	.3 api.
	.3 assets.
	.3 components.
	.3 layouts.
	.3 redurcers.
	.3 service.
	.3 views.
	.3 App.js.
	.3 inedex.js.
	.3 logo.svg.
	.3 routes.js.
	.3 setupProxy.js.
	}
	\caption[Struktura souborů frontendu, vlastní tvorba -- src]{Struktura souborů frontend -- src}
	\label{fig:frontendStructureSrc}
\end{figure}
Zdaleka nejdůležitější je ovšem src složka, která obsahuje samotný kód.
Půjdeme-li popořadě, tak první složkou je actions, kde se nacházejí akce manipulující s Redux storem (viz kapitola 2.3).
S ním také manipulují reducery ve složce redurcers.


\newpage
\subsubsection{Api}


\begin{figure}[h]
	\dirtree{%
	.1 client.
	.2 src.
	.3 api.
	.4 api.
	.4 model.
	.4 ApiClient.js.
	.4 index.js.
	.4 WebSockets.js.
	}
	\caption[Struktura souborů frontendu -- api, vlastní tvorba]{Struktura souborů frontend -- api}
	\label{fig:frontendStructureApi}
\end{figure}
Ve složce api se nachází kód na získání a odesílání dat na backend (viz kapitola 2.2).

\subsubsection{Assets}

\begin{figure}[h]
	\dirtree{%
	.1 client.
	.2 src.
	.3 assets.
	.4 css.
	.4 fonts.
	.4 img.
	.4 scss.
	.5 custom.
	.5 lbd.
	.5 lbdr.
	}
	\caption[Struktura souborů frontendu -- assets , vlastní tvorba]{Struktura souborů frontend -- assets}
	\label{fig:frontendStructureAssets}
\end{figure}
Ve složce assets se nachází vše, co se týká stylů, obrázků a fontů potřebných pro projekt.
Kód napsaný v assets/scss se díky preprocessoru zkompiluje do css souborů do složky assets/css, které se poté odesílají spolu s HTML souborem.
Většina stylů byla zachována z templatu, jelikož jsou styly vcelku použitelné i na požadavky projektu. Například díky nim funguje responzivní navigace.

V některých případech bylo ovšem nutné napsat vlastní styly.
Ty jsou uloženy ve složce assets/scss/custom.
Do souboru light-bootstrap-dashboard je poté přidán import každého z custom souborů.

\newpage
\subsubsection{Components}

\begin{figure}[h]
	\dirtree{%
	.1 client.
	.2 src.
	.3 components.
	.4 Cards.
	.4 Dialogs.
	.4 Footer.
	.4 Form.
	.4 Icons.
	.4 Navbar.
	.4 RouteComponents.
	.4 Sidebar.
	.4 Tables.
	.4 Terminal.
	.4 ProjtecedRoute.js.
	.4 UserSetup.js.
	}
	\caption[Struktura souborů -- components, vlastní tvorba]{Struktura souborů -- components}
	\label{fig:frontendStructureComponentes}
\end{figure}

Složka components obsahuje znovupoužitelné komponenty, ze kterých se poté skládají jednotlivé stránky.
Na ní přímo navazuje složka views, v níž se nachází kód, který jednotlivé komponenty spojuje do stránek.
Když tedy uživatel zadá do URL baru cestu, zobrazí se mu právě jedna stránka složená z několik komponent.
Tyto stránky jsou poté obaleny ještě do tzv. layoutů nacházejících se ve složce layout.
Stránky jsou v nich spojeny s navigacemi a zápatím.
Momentálně existuje pouze jeden layout a to layout pro uživatele (User.js).
V budoucnu je ovšem plánováno rozšířit také projekt pro administrátorský přístup, layouty tedy přibydou.



\subsubsection{Service}


Ve složce service se nacházejí služby, které mohou využívat jakékoliv další služby.
Jedná se o různé druhy výpočtů, např. převádění jednotek, počítání stavů grafů atd...

Soubor index.js je nejvyšším souborem, který do root divu v HTML vloží celý frontend.
Zároveň obsahuje kód pro integraci reduxu.
Soubor App.js obsahuje komponentu, která seskupuje všechny layouty a dovoluje a podílí se na navigaci na frontendu (viz kapitola 2.4).
Stejně tak si v kapitole probereme i soubor routes.js.

\newpage
\subsubsection{View}

\begin{figure}[h]
	\dirtree{%
	.1 client.
	.2 src.
	.3 views.
	.4 Containers.
	.5 Console.js.
	.5 Container.js.
	.5 Info.js.
	.5 Snapshots.js.
	.5 StateHistory.js.
	.4 Other.
	.4 Projects.
	.5 Container.js.
	.5 Info.js.
	.5 Project.js.
	.4 User.
	.5 Dashboard.js.
	.5 Project.js.
	.6 UserProfiel.js.
	}
	\caption[Struktura souborů -- view, vlastní tvorba]{Struktura souborů -- view}
	\label{fig:frontendStructureView}
\end{figure}

Ve složce views sídlí jednotlivé stránky.
Ty jsou v ní dále rozděleny podle toho, do jaké kategorie spadají.
Zde jsou vidět všechny tři kategorie.
Ve složce Other se poté nacházejí stránky z templatu pro případ, kdy by bylo možné někdy použít některé z template komponentů.

\section{API}

Veškerý kód, který má něco společného s komunikaci s backendem či jinými externími zdroji sídlí ve složce api. Obsah této složky kromě WebSockets.js je generován pomocí programu swagger-codegen v již zmíněném Swagger editoru.

Ve složce api/api se poté nachází soubor, kde jsou vygenerované metody odpovídající cestám na REST API, těmto metodám stačí předat specifikované parametry a na server se odešlou požadovaná data. Po získání odpovědi je zavolán předaný callback.

Swagger codegen vygeneroval soubory, které jako API klienta používají knihovnu superagent. Jeho chování je specifikováno pomocí vygenerovaného souboru ApiClient. Vygenerovaný kód ovšem nestačí, např. pokud by vrácená odpověď byla 401, tak bylo nutné do souboru přidat příkaz na spuštění autentifikace.

Ve složce models se nachází soubory odpovídající objektům z Open API specifikace. Na frontendu je ovšem vůbec nevyužívám, slouží tedy pouze samotnému fungování API.

Vše je poté přehledně dostupné v souboru index.js, ze kterého jsou exportovány všechny objekty z model složky a cesty z api/api/DefaultAPI.js

Posledním souborem je WebSockets.js, ve kterém se nachází metody vytvářející WebSocket spojení na backend. Momentálně se WebSockety využívají pouze pro vytvoření spojení pro terminál do kontejnerů, ale v budoucnosti je očekávané, že se jejich využití rozšíří. V případě, že bude spolu na jednom projektu spolupracovat více uživatelů, bude nutné pro vytvoření real-time systému updatovat změny pomocí duplexního spojení, kterým je právě WebSocket.

Jelikož při developmentu nejsou backend a frontend na jednom portu, dochází ke CORS erroru. Na jeho vyřešení byla implementována http proxy (soubor setupProxy.js), která veškeré specifikované requesty přesouvá na port 5000 se stejnou adresou.


\section{Redux}

Redux je framework, který dovoluje různým React komponentům sdílet stav pomocí tzv. Redux store.
V případě, že nějaký komponent potřebuje přistoupit k nějaké části storu, tak se napíše metoda mapStateToProps a jednotlivé proměnné jsou poté předány jako properties jednotlivým komponentám.
V případě, že dojde ke změně redux storu, dojde k překreslení daného komponentu.


Základní chování Redux storu je, že se vynuluje při načtení stránky.
Z tohoto důvodu se store ukládá do localstorage při každé jeho změně.
Při načtení stránky se poté z localstorage načte zpět.
O inicializaci a chování stavu se stará soubor index.js v src složce.

\begin{figure}[h]
	\centering
	\includegraphics[height=6.9cm]{../img/Redux.png}
	\caption[Graf stavu u reduxu, vlastní tvorba, vygenerováno pomocí redux dev tools ]{Graf stavu u Reduxu}
	\label{fig:redux}
\end{figure}


Se storem je možné manipulovat pouze pomocí tzv. akcí.
Jedná se o objekty, které obsahují jméno a payload.
Tyto akce se nacházejí ve složce actions v odlišných souborech pro uživatelské akce, akce s projekty, akce s uživateli a frontendové akce.
Tyto akce mohou být tzv. dispatchnuty, čímž se dostanou k reducerům.

\begin{figure}[h]
	\dirtree{%
	.1 client.
	.2 src.
	.3 actions.
	.4 ContainerAction.js.
	.4 FrontendAction.js.
	.4 ProjectAction.js.
	.4 UserAction.js.
	}
	\caption[Struktura souborů frontendu -- actions, vlastní tvorba]{Struktura souborů frontend -- actions}
	\label{fig:frontendStructureSrc}
\end{figure}


Reducer je metoda, která na základě jména a payloadu předané akce určí, co se má stát s Redux storem.
Tento způsob změny stavu se může zdát zvláštní, každopádně zajišťuje vynikající škálovatelnost systému.
V současnosti existují v projektu dva reducery, combinedUserData reducer, který se stará o veškeré akce související se změnou dat definovaných pomocí Open API a frontend reducer, který má pouze jediný účel na frontendu.
V budoucnosti pravděpodobně nebude nutné mít více než jeden reducer, jelikož logika, kterou frontend reducer vykonává pravděpodobně bude změněna do podoby, kdy frontend reducer nebude potřeba.

Akce mohou být i asynchronní, což se např. hodí pro případ, kdy chceme poslat request na API a jakmile získáme výsledek, tak udělat se získanými daty nějakou akci - např. akce containerIdDelete() ihned zobrazí u mazaného kontejneru v tabulce kontejnerů spinner a nápis deleting.
Po smazání kontejneru se odešle na frontend odpověď a vykoná se akce smazání kontejneru z tabulky.

Jednotlivým komponentům jsou akce předávány pomocí implementace metody mapDispatchToProps, která funguje stejně jako mapStateToProps.

Hlavní účel využití Reduxu v projektu je tedy zpracování dat, které se získají z API do podoby, se kterou mohou komponenty pracovat a poskytnutí možnosti tato data měnit s okamžitými účinky na frontendu.


\section{Navigace}

O navigaci na frontendu se stará knihovna react-router.
Každá cesta na frontendu zobrazující nějakou stránku začíná prefixem daného layoutu.
V případě, že si tedy budeme chtít zobrazit hlavní panel, cesta na získání bude /user/dashboard.
Tím se vždy odliší od volání do api, které má prefix /api.

V projektu se momentálně nachází 1 + N BrowserRouterů.
Jeden v app.js, který se stará o layouty a N v rámci jednotlivých layoutů (nyní N=1).
V nich jsou vytvářeny Route objekty s adresami specifikovanými v routes.js souboru.
V něm se u každé cesty nachází také jméno dané cesty, layout, do kterého patří, navigační linky a stránka, která se má zobrazit, když uživatel zadá danou cestu.

V případě, že uživatel není přihlášen a pokusí se získat chráněný obsah, je okamžitě přesměrován na přihlašovací stránku.
Chráněným obsahem jsou přitom na frontendu s výjimkou jedné cesty úplně všechny.
V případě, že je v Redux storu proměnná combinedUserData.user null, či undefined, tak uživatel není přihlášen.
React-router ovšem neobsahuje žádný komponent ProtectedRoute, takže bylo nutné ho vytvořit.
Jedná se o klasický Route objekt kontrolující, zda je výše jmenovaná proměnná null či nikoliv.

Pro snadný pohyb po stránce byly implementovány dva druhy navigace.
Jak Navbar, tak i Sidebar jsou plně responzivní a přispůsobí se mobilnímu rozhraní, jak ve vidět na obrázcích \ref{fig:desktopRes},  \ref{fig:mobileResO} a \ref{fig:desktopRes}.

\begin{figure}[h]
	\centering
	\includegraphics[height=7.8cm]{../img/navbarNonResponsive.png}
	\caption[Uživatelské rozhraní na počítači, vlastní tvorba]{Uživatelské rozhraní na počítači \linebreak}
	\label{fig:desktopRes}
\end{figure}

\begin{figure}[!htb]
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[height=9cm]{../img/navbarResponsiveSiderbarClosed.png}
		\caption[Responsivní interface na mobilu -- overview, vlastní tvorba]{Responsivní interface na mobilu -- overview}
		\label{fig:mobileResO}

	\end{minipage}\hfill
	\begin{minipage}{0.48\textwidth}
		\centering
		\includegraphics[height=9cm]{../img/navbarResponsiveSiderbarOpened.png}
		\caption[Responsivní interface na mobilu -- sidebar, vlastní tvorba]{Responsivní interface na mobilu -- sidebar}
		\label{fig:mobileResS}
	\end{minipage}
\end{figure}

\newpage

Frontend je strukturován do 3 základních kategorií:
\begin{itemize}
	\item uživatelská - Dashboard, Projects
	\item projektová - Info, Containers, Settings
	\item kontejnerová - Info, Console, Snapshots, Backup, Settings
\end{itemize}

Sidebar - slouží převážně na přepínání mezi kategoriemi.
Dovoluje tedy jednoduše navigovat mezi projektu a jejich kontejnery.
Platí, že vždy je zvýrazněna světlým pozadím ta část sidebaru, která je momentálně zobrazovaná.
Jednotlivé projekty či kontejnery v daném projektu je možné v sidebaru rozbalit či skrýt.
Platí přitom, že nejde skrýt ta část, ve které je aktuálně zobrazený element.
Když je zadána nějaká cesta, ale daný element je zabalený, tak se rodič automaticky rozbalí.

Navbar naproti tomu má za účel navigovat převážně mezi funkcemi jedné kategorie.
Například na výše uvedeném obrázku jsou vidět funkce pro kategorie kontejner - Info, Console, Snapshots, Backup, Settings.
Zároveň se zde nachází i karta s aktuálním uživatelem, na kterou když uživatel klikne, tak mu dropdown nabídne možnost odhlásit se (viz. obrázek \ref{fig:logout}).

\begin{figure}[h]
	\centering
	\includegraphics[height=3.8cm]{../img/logout.png}
	\caption[Odhlášení uživatele, vlastní tvorba]{Odhlášení uživatel \linebreak}
	\label{fig:logout}
\end{figure}

Vlevo se poté nachází jméno dané stránky - u kontejneru je to jméno projektu/jméno kontejneru - jméno stránky.
Zajímavostí je, že při kliknutí na jméno projektu je uživatel odkázán na Info stránku rodičovského projektu.

U obou těchto navigací platí, že jsou implementovány pomocí linků, které odkážou na nějakou cestu, jež se vykreslí za pomoci react-routeru.
Aby bylo jisté, že má uživatel vždy aktuální data, tak se při vykreslování jednotlivých cest vždy dispatchne nějaká akce, která pošle API request na server a po získání dat updatuje Redux store.
Nejprve se tedy vykreslí stará data a jakmile přijde odpověď, tak se vykreslí nová.
To dává pocit kontinuity a je to mnohem více uživatelsky přívětivé, než kdyby se čekalo na získání dat po každém kliknutí.
V budoucnosti, když se bude řešit kooperace více uživatelů se tento systém pravděpodobně změní ve prospěch nějaké formy kontrolního WebSocketu.

\section{Přehled funkcí}

Tato kapitola je věnována detailnímu popisu jednotlivých stránek a komponentů, které potřebují pro své fungování.

\subsection{Hlavní panel}

\begin{figure}[h]
	\centering
	\includegraphics[height=7.3cm]{../img/dashboard.png}
	\caption[Uživatelské rozhraní na počítači, vlastní tvorba]{Uživatelské rozhraní na počítači \linebreak}
	\label{fig:desktopRes}
\end{figure}

Dashboard, neboli hlavní panel zobrazuje uživateli aktuální informace o stavu všech jeho kontejnerů a projektů.
Jedná se o první stránku, kterou po přihlášení uvidí.
Nahoře se nachází dvě karty zobrazující počet projektů, které vlastní a počet různých stavů všech jeho kontejnerů.
Nachází se zde také zobrazení počtu projektů, ve kterých se pouze účastní.
Zatím sice není implementována možnost spolupráce více uživatelů na jednom projektu, ovšem její vytvoření je plánované a jelikož Dashboard vypadá lépe s touto funkcí, tak je tato informace zobrazena již nyní.

Ve druhé řadě se nachází 5 grafů (viz Obrázek \ref{fig:tootip}) zobrazující agregovaný stav všech projektů.
Na jejich implementaci byla použita knihovna react-google-charts - pie-chart.
Červenou barvou se zobrazují zdroje, které jsou opravdu zkonzumovány jednotlivými kontejnery.
Jedná se tedy o součet usage proměnných všech kontejnerů.

\begin{figure}[h]
	\centering
	\includegraphics[height=4.3cm]{../img/tooltip.png}
	\caption[Detail grafu, vlastní tvorba]{Detail grafu}
	\label{fig:tootip}
\end{figure}

Oranžově jsou poté zobrazeny zdroje, které jsou přiděleny jednotlivým projektům či přimo jednotlivým kontejnerům v případě, že samotný projekt limit nemá pro daný zdroj.
Tyto zdroje jsou zablokované a nejde je využít v jiném projektu či kontejneru než tam, kde jsou přiděleny.

Šedivě je zobrazeno volné místo, které je možné alokovat pro další projekty či kontejnery.
Toto volné místo je přitom zobrazeno uvnitř samotného grafu v adekvátních jednotkách.
V řešení problému umístění textu na střed grafu sehrál roli příspěvěk na StackOverflow\footnote{\bibentry{piChart}}.
Dashboard zobrazuje uživatel hlavně proto, aby měl přehled o zdrojích, které může projektům alokovat, dává tedy největší smysl zobrazit právě hodnotu volného místa.
O převod ze základních jednotek se stará třída UnitsConvertor ve třídě service.
Předtím se ještě spočítat všechna potřebná data -- volné zdroje, alokované zdroje, procenta, atd.
O to se stará třída service/StateCalculator.js, jejíž metody modifikují v reducerech stav Redux storu.
Z toho plyne, že data z Redux storu již budou mít všechna potřebná data pro zobrazení stavu k dispozici.

Komponenty grafů se nacházejí ve složce components/Cards/State.
Podobný hlavní panel jako Dashboard pro uživatelskou kategorii se nachází i v projektové a kontejnerové kategorii.
Tam ovšem fungují grafy odlišně, a tak se v této složce nacházejí ještě další dva soubory s odlišnými grafy.

\subsection{Přehled projektů}


\begin{figure}[h]
	\centering
	\includegraphics[height=7.3cm]{../img/projectsOverview.png}
	\caption[Přehled projektů, vlastní tvorba]{Přehled projektů}
	\label{fig:projectOverview}
\end{figure}


Na této stránce má uživatel přehled o všech svých projektech pomocí tabulky.
Ta využívá knihovny react-table a jedná o tabulku od material-ui\footnote{\bibentry{components}} .
Přejatý kód umožňuje vybírat řádky na základě selectu, vyhledávat v tabulce pomocí globálního filtru vpravo nahoře (hledání ve všech sloupcích), řazení dle hodnot ve sloupci a také zajišťuje stránkování, kdy se na další stránku dá přejít pomocí tlačítek vpravo dole.

Stránku reprezentuje soubor views/User/Projects.js a tabulku reprezentují komponenty ve složce components/Table.
Tabulky se nyní vytváření pomocí instancování komponentu EnhancedTable, které je předán Toolbar pro danou tabulku (bar s funkcemi nad daty) a samotná data.
Aby bylo zajištěno, že data jsou aktuální, tak při každém vykreslení stránky se pošle GET request na /api/projects.

Vlastním přínosem do kódu bylo vytvoření SelectBoxu vlevo v Toolbaru, který dovoluje změnit pohled tabulky. Na obrázku níže (obrázek \ref{fig:ram}) můžete poté vidět seznam všech různých pohledů a také příklad jiného pohledu, konkrétně RAM.

\begin{figure}[h]
	\centering
	\includegraphics[height=3.8cm]{../img/ram.png}
	\caption[Pohled na ram, vlastní tvorba]{Pohled na ram}
	\label{fig:ram}
\end{figure}

Pohledy RAM, CPU, Disk, Upload, Download zobrazují podobné informace jako jednotlivé grafy v sekci Informace o projektu (kapitola 2.5.3).
Je ovšem výhodné je vložit i do tabulky, jelikož lze kontejnery řadit podle volných, alokovaných či uložených zdrojů a díky tomu je při nedostatku místa snadné hledat projekty, ve kterých je možné ušetřit nějaké zdroje.
Jestliže projekt nemá nastavené limity, nezobrazuje se progress bar ani procenta u žádné z hodnot, jelikož by to nemělo větší smysl. Zobrazují se ovšem stavy v daných jednotkách.

Uživatel může smazat více projektů najednou.
Stačí vybrat projekt pomocí tlačítka nalevo a Toolbar se změní - zfialoví a zobrazí se počet zobrazených projektů následovaný tlačítkem Delete (viz obrázek \ref{fig:projectSelect}).

\begin{figure}[h]
	\centering
	\includegraphics[height=3.6cm]{../img/project.png}
	\caption[Výběr projektu, vlastní tvorba]{Výběr projektu}
	\label{fig:projectSelect}
\end{figure}

Při kliknutí na ikonu delete se zobrazí dialog, kde se uživatele aplikace zeptá, zda chce smazat tento projekt.
Při kliknutí na Yes se vyšle akce na server a zároveň se změní Redux store. Díky tomu se místo select boxu zobrazí spinner (viz obrázek \ref{fig:detelePro}) s aktuální akcí.

\begin{figure}[h]
	\centering
	\includegraphics[height=0.35cm]{../img/deletingPro.png}
	\caption[Smazání projektu, vlastní tvorba]{Smazání projektu}
	\label{fig:detelePro}
\end{figure}

Jakmile přijde ze serveru zpráva o smazání, okamžitě se kontejner smaže.
Vytvořit projekt je možné pomocí tlačítka + úplně nalevo Toolbaru. Po stisknutí se otevře následující

\begin{figure}[h]
	\centering
	\includegraphics[height=6.5cm]{../img/createPro.png}
	\caption[Vytváření projekt, vlastní tvorba]{Vytváření projektu}
	\label{fig:createPro}
\end{figure}

Při vytváření projektu je nutné specifikovat jeho jméno, které nesmí být delší než 30 znaků a nesmí se v listu projektů opakovat.
Zároveň je možné specifikovat také limity.
V případě, že se stiskne switch, je nastaven limit projektu na specifikovanou hodnotu, v opačném případě projekt nebude mít daný zdroj limitován a bude při výpočtech použit limit uživatele daného zdroje.
Maximální limity jsou určeny jako volné místo ve stavu uživatele.


Po kliknutí na create se zobrazí stejný spinner jako u smazání, akorát s textem creating.

\subsection{Informace o projektu}

\begin{figure}[h]
	\centering
	\includegraphics[height=7cm]{../img/proinfo.png}
	\caption[Informace o projektu, vlastní tvorba]{Informace o projektu}
	\label{fig:proinfo}
\end{figure}


Stránka pro informace projektu je první ze stránek kategorie projektů.
Na první pohled vypadá podobně jako Dashboard.
Vpravo nahoře je vidět počet kontejnerů v projektu a dole jsou grafy, které fungují úplně na stejném principu jako grafy v Dashbaord.

Liší se však v případě, že kontejner nemá nastavené limity u některého ze zdrojů.
V takovém případě se zdroje kontejnerů vztahují přímo k uživatelským limitům.
Platí tedy, že součet limitů zdroje projektů a limitů zdrojů kontejnerů v projektech, kde limity zdroje nejsou musí být menší než limit zdroje uživatele.
Grafy v takovém případě vypadají takto.
Oranžově jsou zobrazeny alokované zdroje pro kontejnery v daném projektu, červeně využité zdroje kontejnerů v projektu, tmavě hnědé jsou alokované zdroje uživatele u ostatních projektů a černě využité zdroje ostatních projektů.

\begin{figure}[h]
	\centering
	\includegraphics[height=3cm]{../img/graphTop.png}
	\caption[Informace o kontejneru, vlastní tvorba]{Alokace zdrojů u projektů}
	\label{fig:prographtop}
\end{figure}

Všimněme si, že volná část zdrojů daného projektu musí být stejná jako volná část daného uživatelského zdroje.

\begin{figure}[h]
	\centering
	\includegraphics[height=3cm]{../img/graphBot.png}
	\caption[Informace o kontejneru, vlastní tvorba]{Alokace zdrojů u uživatele}
	\label{fig:prographbot}
\end{figure}


Další rozdíl je v levé horní kartě, která zobrazuje základní info o projektu.
Pro budoucí využití je také zobrazován Owner a Coworkers v daném projektu, přestože tyto funkce budou implementovány až v budoucnu.
Nachází se zde také tlačítko Delete, které funguje stejně jako tlačítko Delete v předchozí kapitole.

Oproti základní stránce také přibyly linky v navigaci, pomocí nichž se dá navigovat v rámci projektové kategorie.
Info ukazuje na tuto stránku, Containers na přehled kontejnerů a Settings spustí dialog na nastavení projektu.

\subsection{Přehled kontejnerů}

Principielně se stránka nijak neliší od přehledu projektů.
Zobrazovány jsou základní informace, limity a stav kontejnerů.
Liší se hlavně funkcemi, které nabízí Toolbar.
Ten je zde rozšířen o funkce start, stop a freeze.
\begin{figure}[h]
	\centering
	\includegraphics[height=1cm]{../img/contool.png}
\caption[Toolbar pro kontejner, vlastní tvorba]{Toolbar pro kontejner}
	\label{fig:proinfo}
\end{figure}

Po kliknutí na jednu z těchto ikon se vyvolá daná akce pro všechny označené kontejnery, u kterých je daná akce vhodná.
V případě, že se např. pokusí uživatel nastartovat již běžící kontejner, akce se neprovede.
Forma, kdy se zobrazí pouze takové akce, které jsou vhodné, není možná kvůli možnosti vykonat akci pro více kontejnerů najednou.

Dialog pro vytvoření kontejneru je téměř totožný jako dialog pro vytvoření projektu.
Nastavení limit je ovšem povinné, a tak jsou odstraněny switche.
Jsou také přidány inputy pro heslo na root účet v daném kontejneru, checkbox button list pro základní aplikace, které je možné nainstalovat a radio button list pro výběr templatu.
Zobrazí se přitom pouze ty templaty, jejichž minimální usage je menší než aktuální volné místo, které kontejner může potenciálně zabrat.

\subsection{Nastavení projektu}
Přes link settings v navigaci může uživatel změnit nastavení daného projektu.

\begin{figure}[h]
	\centering
	\includegraphics[height=7cm]{../img/proset.png}
	\caption[Nastavení projekt, vlastní tvorba]{Nastavení projektu}
	\label{fig:proset}
\end{figure}


Na začátku se v dialogu zobrazí aktuálně nastavené jméno a limity, kdy počáteční limit je reprezentován labelem na slideru. Pokud se klikne na tlačítko update, odešle se žádost na server o změnu.

\subsection{Informace o kontejneru}

\begin{figure}[h]
	\centering
	\includegraphics[height=7cm]{../img/conInfo.png}
	\caption[Informace o kontejneru, vlastní tvorba]{Informace o kontejneru}
	\label{fig:coninfo}
\end{figure}

Stránka informací o projektu stojí opět na stejném základě jako ostatní stránky s informacemi. Nahoře se nachází karty s informacemi a tlačítky pro ovládání. Narozdíl od tabulky kontejnerů se zde tlačítka pro změna stavu mění na základě aktuálního stavu. Při spuštěném kontejneru tedy nemůžete kliknout na tlačítko start.

Liší se také v grafech. Zatímco předešlé informační panely zobrazovaly, kolik zdrojů zbývá, zde je tomu kromě disku naopak, jelikož není potřeba zobrazovat alokované zdroje. V takovém případě je tato možnost uživatelsky přívětivější.
Přibyla také karta pro zobrazení aktuálního počtu běžících procesů a také možnost zobrazit si historii stavů 2 hodiny nazpět. Tato stránka je ovšem stále ještě ve výrobě, nebudu jí tedy věnovat více prostoru.

\subsection{Terminál}

Jako terminálový emulátor byla využita knihovna xterm a při integraci do aplikace byly využity části kódu z githubu\footnote{\bibentry{xterm}}.

Pro vytvoření spojení s terminálem kontejneru se pošle API request na backend, který vrátí data potřebná pro vytvoření spojení s terminálem. Ihned poté se na základě získaných dat vytvoří dva WebSockety. Přes první z nich se posílají terminálové příkazy a získávají výsledky. Druhý WebSocket slouží poté jako kontrolní WebSocket umožňující s manipulací terminálu. Posílají se přes něj příkazy pro změnu rozměrů kontejneru. To zajišťuje, že terminál je plně responzivní.

\begin{figure}[h]
	\centering
	\includegraphics[height=7.3cm]{../img/terminal.png}
	\caption[Terminál, vlastní tvorba]{Terminál}
	\label{fig:projectOverview}
\end{figure}


Spojení s kontejnerem se začne vytvářet okamžitě po vykreslení komponentu (metoda componentWillMount) s konzolí a ukončuje tehdy, když je tento komponent odstraněn ze struktury (metoda compontWillUnmount).

Jelikož jsou pro každý terminál vytvořené oddělené WebSockety, je možné otevřít více terminálů najednou. Dokonce je možné vytvořit i více terminálů do stejného kontejneru.



\subsection{Backup}

Backup je momentálně implementován tak, že při kliknutí na link Backup bude uživateli zobrazen odkaz, na který když klikne, bude otevřen nový tab, přes který se soubor stáhne. Záloha se nezačne odesílat automaticky, chvíli totiž trvá, než ji backend vytvoří. Tato prodleva je okolo 20 sekund.

Aktuální způsob vůbec nepoužívá na stažení zálohy API klienta, veškeré stahování zařizuje přímo prohlížeč. Tento systém byl zvolen z důvodu, že http proxy nepropustí odpověď serveru typu stream. Jelikož se problém nepodařilo zatím vyřešit, bylo implementováno toto nouzové řešení.

Jakmile bude však problém vyřešen, je připraven kód pro uživatelsky přívětivé stahování backupu. Při kliknutí na tlačítko se zobrazí spinner se zprávou Creating backup, který bude následně vystřídán textem, jež bude popisovat proces stahování.

\subsection{Nastavení kontejneru}
Při kliknutí na link Settings se zobrazí podobný dialog jako při nastavování projektu. Je možné změnit limity, jméno a pokud uživatel bude chtít, tak i root heslo. To poté nahradí stávající heslo kontejneru. Je tak vyřešená změna hesla pro kontejnery.


\chapter{Backend}

Kapitola backend se věnuje backednu progamu.
V první sekci se zaměří na progamovou implementaci práce s LXD a v druhé popíše databáze, jenž projekt využívá.
Poslední sekcí je networking, kde je rozebrána problematika sítí ve spojení s kontejnery.

\section{LXD}

Tato kapitola podrobněji vysvětluje samotné naprogramování podoby funkčnosti uvedené v kapitolách architektury LXD. Také jsou zde uvedeny prvky, které poskytují prostor pro snadné rozšíření stávajících funkcí.
Veškerá komunikace projekt s LXD probíhá přes REST API. Pro zjednodušení požadavků obsahuje backend soubor lxdRoute.js, který zbytku backendu umožňuje snadno a efektivně přistupovat k údajům LXD. Ve zprostředkování všech těchto užitečných funkcí potřebných pro fungování tohoto projektu stálo ale nemálo překážek. Tato kapitola uvádí úhlavní problémy, jimž bylo čeleno, dále výslednou strukturu, a odděleně také sekci pro komunikaci přes WebSocket.

\subsection{Standard odpovědí z rozhraní s LXD}
Na začátek můžeme uvést některé standardy návratových hodnot z lxdRoute.js. Většinou je návratovou hodnotou metod status provedení akce, který je v tomto projektu reprezentován objektem OperationState. Ten obsahuje pouze proměnné status a statusCode. Jeho přední využití u všech metod je uložení dat o výsledném stavu akce/metody. Stav může být jakýkoli z http kódů, které LXD navrátí, pokud vrátí chybovou hlášku, její error\_code je uložen do pole statusCode a popis důvodu chyby samotné bude v statusu. Ve zbylých případech, kdy se nevrací OperationState, jako výchozí hodnota při úspěšném provedení akce, se jedná o doplnění dat do předaného objektu, kupříkladu již dříve zmíněné zjištění stavu.

Zvláštní výjimku tvoří metoda execInstance, jež taktéž používá OperationState, ale pole status obsahuje text, vypsaný příkazem spuštěným v daném kontejneru, případně výstup do errorového proudu, pokud byl příkaz vykonán s návratovou hodnotou jinou než 0. StatusCode je potom buď 200, pokud se příkaz vykonal úspěšně, nebo 400, pokud příkaz skončil s jakýmkoli nenulovým exit statutem. K dispozici je ještě druhá forma vráceného OperationState objektu, tu získáme, pokud výslovně uvedeme, že nechceme obdržet výstup příkazu. Potom dostaneme statusCode s hodnotou představující návratovou hodnotu příkazu, který jsme zadali spustit.

\subsection{Hlavní dorozumívací prvky}
Komunikace všeho druhu má obvykle sjednocující formát, jako například výše uvedený systém návratových hodnot; REST API od LXD se tomu příliš neliší, hodí se proto jisté základní konsolidační funkce, které tyto společné prvky komunikace zpracovávají v jednotný a snadno použitelný výstup.

Jelikož LXD poskytuje pouze zabezpečené připojení (HTTPS, WSS), stává se první nutností načtení klíče a certifikátu LXD. Ty jsou uloženy v serverové části pod složkou config, jejíž obsah je znám pouze backendu. Tyto, a pár dalších základních, neměnných dat, obsažených v podrobnostech každého dotazu na LXD, sestavuje metoda mkOpts(). Aby vyplnila všechny běžně potřebné informace k vytvoření requestu, přidává také předanou cestu a metodu (výchozí je GET). Tato metoda je určena pouze k připravení nezbytných základních dat, je tedy součástí každého dotazu na LXD.

Vyšší, již specifikovanější nadstavbu, tvoří metoda mkRequest(), která je určena k maximálnímu zjednodušení vytváření běžných dotazů, aniž by tím výrazně omezila možnosti poskytované nodejs. Základy získává přes mkOpts() a případná JSON data k odeslání dále zpracuje a odešle LXD v requestu. Vrací vždy až kompletní odpověď LXD, už jako čitelný objekt. Tento přístup nelze využít pouze u metod, které pracují s proudy dat, jako je například posílání souborů a stahování nebo nahrávání záloh kontejnerů.

Poslední ústřední metodu tvoří getOperation(), která na základě předaného objektu výsledné odpovědi LXD může vyčkat, dokud nedoběhne jakákoliv akce, na kterou se daná operace vztahuje. Častěji využívanou funkcí této metody je ale její návratový objekt OperationState, vyjadřující stav, či výsledek jakéhokoli LXD objektu, který je funkci předán. Použití tedy vede, mimo vyčkání na dokončení operací neurčité délky, především k odchytávání potenciálně vzniklých chyb, které LXD vrátilo a předat je jako jednoduchý, formátem vždy identický objekt. Dle něj se dále posuzuje, zda ukončit, či pokračovat, aktuální činnost volající metody.

Tyto tři funkce tvoří hlavní rozhraní pro všechny metody v lxdRoute.js, jsou proto naprosto nepostradatelné a značně napomáhají psaní a přehlednosti jakýchkoliv metod komunikujících s LXD.

\subsection{Potíže s limity}
LXD ukazuje, že v něm existují všechny základní potřebné limity pro omezení využívání hardwarových zdrojů.
Bohužel po dlouhém zkoumání a testování jsme si ověřili, jak moc jsou tyto informace nepravdivé.

Na začátek je důležité uvést, že z původně plánovaného ovládání limitů (času procesoru, použité paměti RAM, využívaného disku a provozu internetu na projektech i kontejnerech LXD) bylo bohužel nezbytné přístup k limitům značně změnit.

V první řadě se limity projektů vůbec nenastavují v LXD, jsou tedy používány pouze k výpočtu limitů kontejnerů, důvodem tohoto rozhodnutí bylo nesmyslné chování LXD, které po nastavení limitů projektu neumožňovalo vytvářet kontejnery. Důvodem prý bylo, že kontejnery musejí mít také nastavené limity, které byly nastaveny u projektu, přestože jsme toto při vytváření kontejnerů dodržovali.
Druhým ústupkem z původního plánu bylo upuštění od omezování zabraného místa na disku, v tomto případě měly takto omezené kontejnery náhodné chování při startování – většinou se nespustily a vrátily chybovou hlášku, která byla naprosto zcestná\footnote{\bibentry{resolve}}.

Startovní limity se nastavují kontejnerům vždy při vytvoření. Změny limitů jsou pak možné jejich záplatováním (voláním requestů s metodou PATCH). Výslednými limity, které zde byly nakonec použitelné, byly tedy pouze u kontejneru, a to procesor, pamět RAM a trafika komunikace na síti (download, upload).

\subsection{Zpřístupnění WebSocket terminálu}

Správné websockety dostane klient HTTP dotazem na /api/instances/[id]/console. Ten vrátí buď chybovou zprávu – něco pokazí (přeruší spojení), nebo pokud uživatel nemá oprávnění k přístupu ke kontejneru daného [id] –, nebo objekt s poli terminal a control, která představují ID websocketů, na které se klient může připojit pomocí již zmíněné cesty /websockets/terminals/[id websocketu], Socket terminálu přijímá jakýkoli vstup a rovnou jej přesměrovává na LXD, control oproti tomu sice také přeposílá cokoli dostane, ale pro projevení účinku musí každá zpráva odpovídat formátu vyžadovanému LXD (viz obrázek \ref{fig:resize}). Zde si lze povšimnout podivného zápisu čísel jako řetězců, domníváme se, že tento zápis byl zvolen pro umožnění změn šířky dle jiných jednotek, oproti výchozí jednotce – znak. Zda již je něco takového implementováno, nelze bohužel kvůli nedostačující dokumentaci LXD zjistit.

\begin{figure}[h]
\centering
\begin{lstlisting}[tabsize=3]
{
	"command": "window-reize",
	"args":{
			"width": "80",
			"height": "50,
	}
}
\end{lstlisting}
\caption{resize příkaz}
\label{fig:resize}
\end{figure}


Websockety je nutné uložit, protože se vytvářejí spolu s voláním na získání jejich id od klienta, aby se na ně mohl poté připojit. Soubor websocket.js ve složce services, který se stará o veškerou práci s websockety mezi LXD a klientem, obsahuje k tomuto účelu mapu, jejíž záznamy jsou uloženy pod stringem id svého websocketu, který reprezentují. Objekt záznamu obsahuje samotný websocket, pod jehož id je uložen, dále proměnnou control, nebo terminal, obsahující id druhého LXD websocketu, se kterým se vážou, a pak také proměnnou s klientským websocketem, který se na jejich lxd websocket napojuje.

Tyto proměnné se využívají ve websocketách klientova terminálu a obou lxd socketů (terminál a kontrola velikosti – control) – na nichž jsou zaregistrovány callbacky na ukončení spojení s websocketem, což ukončí i ostatní –, kde poskytují odkazy na ostatní websockety, aby mohly být při konci relace také zavřeny. Významově hlavní callback je na lxd socketu control, který se zavře a ukončí i zbylé sokety v moment, kdy uživatel zadá exit v hlavním shellu, který představoval terminál jeho kontejneru. Díky tomu není třeba zpracovávat zprávy ani jedné strany, a přesto poznáme, kdy uživatel vyšel z hlavního procesu. Pokud spojení ukončí klientský socket terminálu, uzavře se nejdřív lxd socket control, jehož ukončení již zajistí ukončení všech ostatních.



\section{Databáze}

Sytém používá dva databázové systémy -- mySQL (mariaDB) a mongoDB.
Dle původních představ měl používat pouze mySQL.
Kvůli komplikacím s lxd, kde nejde zjistit stav zastaveného/vypnutého kontejneru, byla později zavedena mongoDB.

\subsection{MySQL}
Následující sekce se zabývá strukturou mySQL databáze a metodami, které s databází zacházejí.


\begin{figure}[h]
	\dirtree{%
	.1 src.
	.2 services.
	.3 sql.
	.4 containerSQL.js.
	.4 projectSQL.js.
	.4 templateSQL.js.
	.4 userSQL.js.
	}
	\caption[Soubory s programem týkající se mysql databáze, vlastni tvorba]{Soubory s programem týkající se mysql databáze}
	\label{fig:sqlClasses}
\end{figure}

Valnou většinu dat projekt ukládá do MySQL databáze, kde je na tento účel vytvořeno aktuálně 10 tabulek.
S databází pracují 4 soubory (viz. \ref{fig:sqlClasses}) \textit{containerSQL} zpracovává věci týkající se uživatelů, \textit{projectSQL} věci týkající se projektů, \textit{templateSQL} věci týkající se šablon a aplikací, v neposlední řadě \textit{userSQL} věci týkající se uživatele.

\subsubsection{Tabulky}

Tato sekce spěšně popíše obsah jednotlivých tabulek. A jejich vztah k ostatním. Kaskádové dependence jsou vždy stejné -- při smazání se podřadné záznamy smažou, při update se nic neděje.

\vspace{0.3cm}
\noindent
\textbf{appsToInstall} | id | name | description | icon\_path | package\_name |

Tabulka appsToInstall slouží k uložení aplikací, které je možno nainstalovat na kontejner při jeho vytváření.
Nemá žádnou vazbu na další tabulky a s jejími daty zachází třída templateSQL.
Sloupec name obsahuje jméno jaké se má zobrazit uživateli, package\_name je jméno balíčku v repositářích.

\vspace{0.3cm}
\noindent
\textbf{containers} | id | project\_id | name | url | template\_id | state | timestamp \linebreak[4] | time\_started |

Tabulka container ukládá všechny kontejnery, které spravujeme.
Obsahuje dva cizí klíče a to project\_id, které určuje do jakého projektu kontejner patří, a template\_id to určuje s jakou šablonou byl kontejner vytvořen.


\vspace{0.3cm}
\noindent
\textbf{containersResourcesLimits} | container\_id | ram | cpu | disk | upload | download |

Tabulka containersResourcesLimits ukládá limity kontejneru, stejně jako u dalších ResourcesLimits tabulek byla v rámci normalizačních forem oddělena od tabulky containers.
Tabulka obsahuje jeden cizí klíč, který zároveň funguje i jako primární klíč.
Veškeré limity jsou uloženy v základních jednotkách, cpu je v abstraktní jednotce herz\footnote{Maximální hodnota je počet jader*kmitočet procesoru, do LXD se přepočítává na procenta} .

\vspace{0.3cm}
\noindent
\textbf{containersResourcesLog} | container\_id | ram | cpu | number\_of\_processes | upload | download | timestamp |

Tabulka containersResourcesLog slouží k logování stavu kontejnerů.
Container\_id je cizím klíčem odkazující na kontejner, ke kterému log patří.
V aktuální verzi jsou data uložena v poli, které uložené ve sloupci s typem text.
Timestamp odkazuje na datum posledního zapsání, kdy byl zalogován předchozí stav není problém zjistit, jelikož se do tabulky zapisuje v pravidelných intervalech.

Metoda na updateování stavu (updateLogsForContainer(id, state)) si jednoduše data rozdělí dle znaku: \textbf{,}.
Do pole se přidají nové hodnoty a odebere se první prvek, nový stav se pak uloží do databáze.

Data se aktuálně do databáze uloží každých 10 minut, o což se stará cronjob (potažmo schedule) definovaný v app.js.
Aktuálně si databáze pamatuje dvanáct záznamů, takže dvě hodiny do minulosti.
Fakt, že log časový rozdíl mezi zápisy nemusí být přesně 10 minut, příliš nevadí, grafy, které se z těchto dat vykreslují jsou spíše orientační.


\vspace{0.3cm}
\noindent
\textbf{projects} | id | name | owner\_email | timestamp |

Tabulka projects si pamatuje všechny projekty, které spravuje náš systém.
Cizím klíčem je owner\_email, což je email vlastníka projektu, tedy člověka, který ho vytvořil.
Timestamp je čas vytvoření projektu.

\vspace{0.3cm}
\noindent
\textbf{projectsCoworkers} | project\_id | user\_email |

Tabulka projectsCoworkers zporstředkovává M:N vazbu mezi users a projects.
Slouží k uložení lidí, kteří jsou spolupracovnící na jednom projektu.
K datu odevzdání práce, nejsou spolupracovnící implementované, takže tabulka je aktuálně zbytečná.
Řada metoda nepočítá s existencí spolupracovníků.

\vspace{0.3cm}
\noindent
\textbf{projectsResourcesLimits} | project\_id | ram | cpu | disk | upload | download |

Tabulka projectsResourcesLimits slouží k uložení limitů projektu.
Nerozdíl od containersResourcesLimits můžou zde mít limity hodnotu null.
V takovém případě je kontejnerům dostupný vešerý volný prostor, který uživatel má.

\vspace{0.3cm}
\noindent
\textbf{templates} | code | id | profile\_name | image\_name | version | profile\_description | image\_description | profile\_path | min\_disk\_size |

Tabulka templates slouží k uložení šablon, lde kterých se má vytvořit kontejner.
Šablona je koncept, který se nenachází přímo v lxd, ale integruje dvě věci -- profily a image.
Image je distribuce jaká se na systém dá nainstalovat.
Profile je koncept z lxd, který obsahuje konfiguraci kontejneru.
Eventuálně by měl uživatel možnost vytvářet si vlastní profily, které by obsahovali například konfiguraci networků.

\vspace{0.3cm}
\noindent
\textbf{users} | id | email | given\_name | family\_name | icon | role | coins |

Tabulka users slouží k uložení uživatelů.
Svoje data dostává z dat, které zasílá Google Auth 2.0.
Sloupce role a coins aktuálně nemají význam, role bude dělit uživatele mezi standardního uživatel, admina a superadmin.
Admin a superadmin by měli právo zasahovat do kontejnerů jiných uživatelů.
Coins měl být sloupec sloužící u ekonomiky systému, k její implementaci však nedošlo.


\vspace{0.3cm}
\noindent
\textbf{usersResourcesLimits} | user\_id | ram | cpu | disk | upload | download |

Tabulka usersResourcesLimits ukládá limity uživatelů.
Aktuálně má uživatel k dispozici 2.8 GHz\footnote{server kde byl program vyvíjen měl 2 jádra o 2.8 GHz, jedná se tak o polovinu výkonu}, 2 GB ram, 8GB volného místa na disku, a download a upload 800kb/s.

\subsection{MongoDB}

MongoDB je výhodné pro použití při ukládání objektových struktur.
V našem případě je tímto stav kontejneru, ze kterého musíme do databáze uložit velikost na disku a všechna data o síťových spojeních.
Používáme pouze jednu databázi – lxd; tabulky by podle databázových pravidel SQL měly být tři (projekty, stavy kontejnerů a napojení stavů kontejnerů na projekty, případně ještě hlubší rozdělení na tabulku s id kontejnerů a id záznamů jejich stavu), ovšem pro zbytečnou komplikovanost, kterou by tento přístup představoval, se vytvářejí tabulky dynamicky a reprezentují stejnojmenné projekty (např. p1, p2).
Záznamy jsou potom objekty, jejichž unikátní \_id je id kontejneru (c1, c2) a obsahují pole disk -- kam se ukládá velikost disku – a pole pro objekt obsahující síťové informace.


Tabulky se vytvářejí a mažou spolu s projekty, stejně tak je tomu i u záznamů jednotlivých kontejnerů, avšak ty vytvoří pouze záznam s \_id, data o stavu se zapíšou pouze před každým vypnutím kontejneru, aby byla nejaktuálnější a zároveň obnovena pouze tehdy, když jsou potřeba -- pro doplnění scházejících dat z volání LXD při vypnutém kontejneru.

\section{Networking}

Následující sekce se zabývá networkingem kontejnerů a proxy, které umožňuje přístup na ně z venčí.

\subsection{Konfigurace networků}

Pomineme li loopback (standardní \textit{lo}), tak každý kontejner má v aktuální verzi právě jeden networkový interface.
Tím je \textit{eth0}, který je na hostovi napojen na bridge \textit{lxdbr0}.
Přes něj mají kontejnery přístup na internet.
Zároveň jsou všechny na stejné síti (prostřednictvím \textit{lxdbr0})

Jelikož jsou veškeré kontejnery na stejné síti, tak mezi sebou mohou komunikovat.
Lxd pro tento účel samo nastavuje jejich interní doménu, ta je ve tvaru \textit{c\{id\}.lxd}.
Pochopitelně však nejsou dostupné z internetu, doména je pouze interní a veřejnou ip adresu nemají.
Aby bylo možno na kontejner přistupovat bylo nutné nastavit proxy, které mu databáze bude přeposílat.

Nutno podotknout, že i traffic mezi kontejnery je aktuálně omezen limitem.
V budoucno se tedy nabízí možnost implementovat možnost vytvářet další bridge a kontejnery si propojovat.
Ty by se mohly ukládat do profilů, uživatel by si tak rovnou mohl vytvořit kontejnerů izolovaný od ostatních.

Fakt, že kontejnery jsou na stejné síti není rizikové ani problematické.
Standartě se nemůžou nijak ovlivňovat.

\subsection{Proxy}

Pro proxy využívá projekt volně dostupnou haproxy, jejíž instance běží ve stejnojmenném kontejneru.
Hostovací stroj totiž standardně nemůže přistupovat na kontejnery prostřednictvím .lxd domény.
Bylo by možné sice mít proxy na hostovi serveru, ale z bezpečnostních důvodů tak nebylo učiněno.

Do kontejneru haproxy je aktuálně přesměrována traffic ze čtyř portů -- 80, 443, 2222 a 3000.
Port 80 pochopitelně slouží na webové stránky pomocí protokolu http.
443 je pro https, proxy má nastavený vlastní ssl certifikát.
Ten stačí jeden pro celý systém, musí se však jednat o certifikát typu wildcard\footnote{Certifikát, který zahrnuje i subdomény. Žáci si tak nemusí pořizovat vlastní.}.
Systém byl testován na standardním certifikátu, čily připojení sice bylo zabezpečené, ale prohlížeč hlásil podezření z fishningu, jelikož se doména a doména na certifikátu neschodovali.
Port 2222 slouží na připojení přes ssh, port 22 používá hošťovací počítač a z pochopitelných důvodů není přesměrován do proxy.
Port 3000 je dostupný pro REST API aplikací, které na serveru budou běžet.

Kotejnerům je automaticky přirazena doména v následujícím tvaru \textit{\{jméno kontejneru\}.\{jméno projektu\}.\{část emailu uživatel, před @\}.\{doména serveru\}}.
Například kontejner pojmenovaný \textit{rumburak} v projektu \textit{web} uživatele \textit{belzebub@email.com} na serveru s doménou \textit{avava.cz} bude mít doménu {rumburak.web.belzebub.avava.cz}.
Mezery ve jméně kontejneru, či projektu se domény odstraní.
Pokud by měl nový kontejner stejné jméno, jako jiný systém vyhodí výjimku.
Tak je zaručena unikátnost domén, u mailu není takový problém nutno řešit, jelikož se jedná o školní emaily, které jsou vždy unikátní.

Bohužel je možno elegantně forwardovat pouze http protokol.
Většina TCP protokolů totiž neoperuje s SNI a řídí se pouze IP adresou.
Z packetu tak nejde zjistit na jakou doménu se uživatel snaží dostat a tedy jakému kontejneru mý být protokol přiřazen.
To by se týkalo i ssh, příkaz ssh však podporuje nastavit pomocí flagu -o ProxyCommand (viz. \ref{fig:sshcom}), packety poté sni v hlavičce mají a je možno poznat jakému kontejneru patří.
\begin{figure}[h]
\begin{lstlisting}[breaklines]
ssh -o ProxyCommand="openssl s_client -connect $SERVERURL:2222 -servername $CONTAINERURL" blank -l $USERNAME
\end{lstlisting}
\caption[Příkaz k připojení na server, vlastní tvorba]{Příkaz k připojení na server\protect\footnotemark}
\label{fig:sshcom}
\end{figure}
\footnotetext{\$SERVERURL je url serveru kde běží kontejnerizační systém, \$CONTAINERURL je url kontejneru, \$USERNAME je jméno uživatel, argument dummy je ignorován, je však potřeba}

Porty jako 8443 aktuálně forwardovány nejsou, pokud uživatel potřebuje přistupovat do datáze běžící na kontejneru je možno použít ssh local port forwarding.
Tento princip je i bezpečnější.

Konfigurační soubor HAProxy je generován v containerSQL.js.
Po jeho vygenerování se prostřednictvím lxd.postFileToInstance pošle nová konfigurace to HAProxy kontejneru.
Restartování proxy je téměř instantní operace i s velkým konfiguračním souborem obsahujícím desítky kontejnerů.
Downtime je tak minimální.
Podoba konfigurace byla realizována za pomocí dokumentace HAProxy\footnote{\bibentry{HaproxyDocs}}.
Aktuálně má formát konfiguračního souboru jisté rezervy, specificky co se týče jeho délky.
Je však o trochu rychlejší než, kdyby byly použity pokročilé metody mapování, které HAProxy podporuje.



\chapter*{}
\pagenumbering{roman}
\setcounter{page}{6}
\include{zaver}

\include{literatura}

\listoffigures
\openright
\end{document}
